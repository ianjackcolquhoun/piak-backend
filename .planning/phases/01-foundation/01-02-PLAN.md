---
phase: 01-foundation
plan: 02
type: execute
---

<objective>
Define the Contact data model TypeScript types for the application.

Purpose: Establish shared type definitions that frontend and backend will use for contact data.
Output: Contact interface and related types that capture both raw notes and structured extraction.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@functions/src/index.ts

**From PROJECT.md - Data requirements:**
- Capture both raw note and structured extraction (never lose information)
- Grouping/organization matters most: tags, companies, locations, meeting context
- Connections (who knows who) are secondary
- Time-based history is tertiary
- Search works against both raw and structured data

**From PROJECT.md - Input patterns:**
- Voice-to-text: "met john at the park he works at fifth third knows craig"
- Typed shorthand: "john - park - fifth third - craig's friend"

**From PROJECT.md - Extraction strategy:**
- Conservative on ambiguous inference
- Normalize data (lowercase tags, standardize company names)
- Return clean JSON without markdown/explanation
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Contact type definitions</name>
  <files>functions/src/types/contact.ts</files>
  <action>
Create comprehensive Contact types that support the dual raw+structured approach:

```typescript
// functions/src/types/contact.ts

/**
 * Structured contact data extracted from natural language input.
 * All fields optional - extraction may not find everything.
 */
export interface ContactData {
  /** Primary name (first name, full name, or nickname) */
  name?: string;

  /** Company or organization */
  company?: string;

  /** Job title or role */
  title?: string;

  /** How/where you met this person */
  meetingContext?: string;

  /** Location associated with meeting or person */
  location?: string;

  /** Categorization tags (normalized to lowercase) */
  tags?: string[];

  /** Names of people this contact knows */
  connections?: string[];

  /** Phone number (if mentioned) */
  phone?: string;

  /** Email address (if mentioned) */
  email?: string;

  /** Any additional notes that didn't fit other fields */
  notes?: string;
}

/**
 * Full contact document as stored in Firestore.
 * Includes both raw input and structured extraction.
 */
export interface Contact {
  /** Firestore document ID */
  id: string;

  /** User ID who owns this contact (from Firebase Auth) */
  userId: string;

  /** Original user input (never lose this) */
  rawNote: string;

  /** AI-extracted structured data */
  extracted: ContactData;

  /** When the contact was created */
  createdAt: Date;

  /** When the contact was last updated */
  updatedAt: Date;
}

/**
 * Input for creating a new contact.
 * Only requires the raw note - extraction happens via AI.
 */
export interface CreateContactInput {
  /** The raw text to extract contact info from */
  rawNote: string;
}

/**
 * Input for updating an existing contact.
 * Can update raw note (triggers re-extraction) or manual field edits.
 */
export interface UpdateContactInput {
  /** Contact ID to update */
  id: string;

  /** New raw note (optional - triggers re-extraction if provided) */
  rawNote?: string;

  /** Manual field overrides (merged with extracted data) */
  overrides?: Partial<ContactData>;
}

/**
 * Input for searching contacts.
 */
export interface SearchContactInput {
  /** Search query (searches both raw and extracted fields) */
  query: string;
}

/**
 * Response from Claude API extraction.
 * This is what the AI returns, which gets stored in Contact.extracted.
 */
export type ExtractionResult = ContactData;
```

Key design decisions:
- All ContactData fields optional (extraction may not find everything)
- rawNote always preserved (search fallback, never lose info)
- extracted is typed but flexible (AI output may vary)
- Separate input types for create/update/search operations
- Date fields for tracking (createdAt, updatedAt)
- userId for user isolation in Firestore queries

Do NOT add validation logic here (types only). Validation happens in function handlers.
  </action>
  <verify>`npm run build` succeeds with no TypeScript errors</verify>
  <done>Contact types defined at functions/src/types/contact.ts, compiles without errors</done>
</task>

<task type="auto">
  <name>Task 2: Create types barrel export</name>
  <files>functions/src/types/index.ts</files>
  <action>
Create a barrel export for easy importing:

```typescript
// functions/src/types/index.ts
export * from './contact';
```

This allows other files to import as:
```typescript
import { Contact, ContactData, CreateContactInput } from './types';
```
  </action>
  <verify>`npm run build` succeeds</verify>
  <done>Types barrel export exists at functions/src/types/index.ts</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd functions && npm run build` succeeds without errors
- [ ] `npm run lint` passes (or only pre-existing warnings)
- [ ] functions/src/types/contact.ts exists with Contact, ContactData, and input types
- [ ] functions/src/types/index.ts exports all types
- [ ] Types can be imported in other files (test by adding import to index.ts)
</verification>

<success_criteria>
- Contact interface defined with id, userId, rawNote, extracted, timestamps
- ContactData interface defined with all optional fields
- CreateContactInput, UpdateContactInput, SearchContactInput defined
- Barrel export at types/index.ts
- All TypeScript compiles without errors
- Phase 1 complete
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md` using summary template.

Include:
- Type definitions created
- Design rationale for dual raw+structured approach
- Phase 1 complete, ready for Phase 2 (Intent Classification)

Update STATE.md:
- Phase 1 complete
- Decisions: Haiku 4.5 model, onCall functions, raw+structured capture
</output>
