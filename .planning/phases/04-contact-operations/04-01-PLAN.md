---
phase: 04-contact-operations
plan: 01
type: execute
---

<objective>
Create contact update function that re-extracts data when rawNote changes and merges manual overrides.

Purpose: Enable users to modify existing contacts with intelligent re-extraction
Output: updateContact onCall function with supporting types
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase context:
@.planning/phases/03-contact-extraction/03-01-SUMMARY.md

# Key source files:
@functions/src/index.ts
@functions/src/types/contact.ts
@functions/src/services/claude.ts
@functions/src/prompts/contactExtraction.ts

**Tech stack available:** @anthropic-ai/sdk, Firebase Functions v2, Firestore
**Established patterns:** onCall with secrets, JSON-only Claude responses, nested try-catch for parse errors
**Constraining decisions:**
- 01-02: UpdateContactInput type already defined (id, rawNote?, overrides?)
- 01-02: rawNote always preserved
- 03-01: 512 maxTokens for extraction
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add updateContact response type</name>
  <files>functions/src/types/contact.ts, functions/src/types/index.ts</files>
  <action>Add UpdateContactResponse interface to contact.ts:
- contact: Contact (the full updated contact)
- reExtracted: boolean (whether extraction was triggered)
- usage?: { inputTokens, outputTokens } (only present if re-extraction occurred)

Export from types/index.ts.</action>
  <verify>npm run build in functions/ completes without errors</verify>
  <done>UpdateContactResponse type exists and is exported</done>
</task>

<task type="auto">
  <name>Task 2: Create updateContact onCall function</name>
  <files>functions/src/index.ts</files>
  <action>Add updateContact onCall function following extractContact pattern:
1. Require authentication (throw HttpsError if !request.auth)
2. Validate input: id required (string), rawNote optional (string), overrides optional (Partial<ContactData>)
3. Get existing contact from Firestore: db.collection("contacts").doc(id)
4. Verify ownership: contact.userId === request.auth.uid (throw "permission-denied" if not)
5. If rawNote provided and different from existing:
   - Call ClaudeService with CONTACT_EXTRACTION_PROMPT and new rawNote
   - Parse JSON response as ContactData
   - Set reExtracted = true
6. Merge data: start with existing extracted, apply re-extraction if any, then apply overrides
7. Build updated contact: { ...existing, rawNote: newRawNote || existing.rawNote, extracted: merged, updatedAt: new Date() }
8. Save to Firestore
9. Return { contact: updated, reExtracted, usage }

Use firebase-admin for Firestore access. Initialize admin at top of file if not already done.</action>
  <verify>npm run build in functions/ completes without errors</verify>
  <done>updateContact function exported, handles re-extraction and overrides, enforces ownership</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds in functions/
- [ ] `npm run lint` passes
- [ ] UpdateContactResponse type exists
- [ ] updateContact function exported from index.ts
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No TypeScript errors
- updateContact handles: auth check, ownership check, re-extraction, overrides merge
</success_criteria>

<output>
After completion, create `.planning/phases/04-contact-operations/04-01-SUMMARY.md`
</output>
