---
phase: 04-contact-operations
plan: 02
type: execute
---

<objective>
Create AI-powered search function that finds contacts by any remembered fragment.

Purpose: Enable fuzzy recall - user searches by partial info and AI matches against contact fields
Output: searchContacts onCall function with search system prompt
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase context:
@.planning/phases/04-contact-operations/04-01-SUMMARY.md

# Key source files:
@functions/src/index.ts
@functions/src/types/contact.ts
@functions/src/services/claude.ts
@functions/src/prompts/intentClassification.ts
@functions/src/prompts/contactExtraction.ts

**Tech stack available:** @anthropic-ai/sdk, Firebase Functions v2, Firestore
**Established patterns:** onCall with secrets, JSON-only Claude responses, system prompts in prompts/ directory
**Constraining decisions:**
- Search works against both raw note and extracted fields (PROJECT.md)
- 256 maxTokens for short responses (classification pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create search system prompt and types</name>
  <files>functions/src/prompts/contactSearch.ts, functions/src/types/contact.ts, functions/src/types/index.ts</files>
  <action>Create CONTACT_SEARCH_PROMPT in prompts/contactSearch.ts:
- Input: user query + array of contacts (id, rawNote, extracted fields)
- Output: JSON array of matching contact IDs with relevance scores
- Instructions: Match against name, company, tags, connections, location, meetingContext, rawNote
- Handle partial/fuzzy matches (e.g., "coffee shop" matches "met at starbucks")
- Return empty array if no matches
- Format: [{ "id": "...", "score": 0.0-1.0, "reason": "..." }]

Add SearchContactResponse to contact.ts:
- results: Array<{ id: string, score: number, reason: string }>
- usage: { inputTokens, outputTokens }

Export from types/index.ts.</action>
  <verify>npm run build in functions/ completes without errors</verify>
  <done>CONTACT_SEARCH_PROMPT exists, SearchContactResponse type exported</done>
</task>

<task type="auto">
  <name>Task 2: Create searchContacts onCall function</name>
  <files>functions/src/index.ts</files>
  <action>Add searchContacts onCall function:
1. Require authentication
2. Validate input: query required (string)
3. Fetch all user's contacts from Firestore: db.collection("contacts").where("userId", "==", request.auth.uid)
4. If no contacts, return empty results
5. Format contacts for prompt: array of { id, rawNote, ...extracted fields }
6. Call ClaudeService with CONTACT_SEARCH_PROMPT and formatted input (query + contacts JSON)
7. Parse JSON response as array of { id, score, reason }
8. Return { results, usage }

Use 512 maxTokens (search results can be longer than classification).
Import CONTACT_SEARCH_PROMPT from prompts/contactSearch.</action>
  <verify>npm run build in functions/ completes without errors</verify>
  <done>searchContacts function exported, queries user's contacts, returns AI-ranked matches</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds in functions/
- [ ] `npm run lint` passes
- [ ] CONTACT_SEARCH_PROMPT exists in prompts/contactSearch.ts
- [ ] SearchContactResponse type exists
- [ ] searchContacts function exported from index.ts
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No TypeScript errors
- searchContacts handles: auth check, empty contacts case, AI-powered fuzzy matching
- Phase 4 complete
</success_criteria>

<output>
After completion, create `.planning/phases/04-contact-operations/04-02-SUMMARY.md`
</output>
