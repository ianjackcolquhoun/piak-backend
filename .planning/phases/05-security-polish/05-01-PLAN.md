---
phase: 05-security-polish
plan: 01
type: execute
---

<objective>
Implement Firestore security rules for user data isolation.

Purpose: Replace dangerous allow-all development rules with production-ready rules that isolate user data.
Output: Secure firestore.rules that enforce ownership-based access control.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Current rules (INSECURE):**
@firestore.rules

**Backend enforces ownership:**
- updateContact checks `existingContact.userId !== request.auth.uid`
- searchContacts queries with `.where("userId", "==", request.auth.uid)`
- Pattern: userId field on each contact document stores owner's auth UID

**Contact document structure:**
```typescript
interface Contact {
  id: string;
  userId: string;        // Owner's auth UID
  rawNote: string;
  extracted: ContactData;
  createdAt: Date;
  updatedAt: Date;
}
```
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement contacts collection security rules</name>
  <files>firestore.rules</files>
  <action>
Replace the temporary allow-all rules with production rules:

1. Remove the timestamp-based allow-all rule
2. Add contacts collection rules:
   - read: allow if authenticated AND document userId == request.auth.uid
   - create: allow if authenticated AND incoming userId == request.auth.uid
   - update: allow if authenticated AND existing userId == request.auth.uid
   - delete: allow if authenticated AND existing userId == request.auth.uid

Use helper function for readability:
```
function isOwner(userId) {
  return request.auth != null && request.auth.uid == userId;
}
```

For create: validate that incoming data has userId field matching auth.uid (prevent users from creating contacts owned by others).

For update: also verify the userId field cannot be changed (prevent ownership transfer).
  </action>
  <verify>Firebase deploy rules succeeds: cd functions && npm run deploy -- --only firestore:rules (or firebase deploy --only firestore:rules from project root)</verify>
  <done>firestore.rules deployed with owner-only access, no allow-all rules remain</done>
</task>

<task type="auto">
  <name>Task 2: Verify rules with emulator tests</name>
  <files>N/A (verification only)</files>
  <action>
Start Firebase emulators and verify rules work correctly:

1. Start emulators: firebase emulators:start
2. Test scenarios manually or document test cases:
   - Authenticated user CAN create contact with their userId
   - Authenticated user CAN read their own contacts
   - Authenticated user CANNOT read contacts with different userId
   - Authenticated user CANNOT create contact with different userId
   - Unauthenticated requests are denied

If emulator testing is complex, verify by deploying to staging and testing with a real authenticated call.
  </action>
  <verify>Rules behave correctly - own contacts accessible, others' contacts denied</verify>
  <done>Security rules verified working with owner isolation</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] firestore.rules no longer has allow-all rule
- [ ] contacts collection has owner-based read/write rules
- [ ] Rules deploy without errors
- [ ] Ownership isolation verified (own contacts accessible, others' denied)
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No security warnings in deployment
- User data properly isolated by userId
</success_criteria>

<output>
After completion, create `.planning/phases/05-security-polish/05-01-SUMMARY.md`
</output>
